import pandas as pd
import numpy as np
from scipy.optimize import minimize_scalar
import talib
from typing import Dict, Optional, Union

class ATRStrategyPro:
    """
    Estratégia ATR Pro para Scalping/Day Trading com:
    - Períodos adaptativos por timeframe
    - Seleção dinâmica do melhor ATR (short/medium/long)
    - Filtros de tendência e momentum
    - Confirmação de volume inteligente
    - Gestão de risco dinâmica
    - Suporte a múltiplos timeframes (30s a 1D)
    - Integração com price action
    """
    
    def __init__(self, config: Optional[Dict] = None):
        config = config or {}
        # Configurações base
        self.base_atr_period = config.get('base_atr_period', 14)
        self.volume_threshold = config.get('volume_threshold', 1.5)
        self.min_confidence = config.get('min_confidence', 70)
        self.position_risk_pct = config.get('position_risk_pct', 0.01)  # 1% para scalping
        self.risk_reward_ratio = config.get('risk_reward_ratio', 1.5)
        
        # Parâmetros adaptativos (agora com ema_long dinâmico)
        self.timeframe_adjustments = config.get('timeframe_adjustments', {
            '30s': {'atr_multiplier': 0.8, 'rsi_period': 8, 'ema_short': 12, 'ema_long': 50},
            '1m': {'atr_multiplier': 0.9, 'rsi_period': 10, 'ema_short': 15, 'ema_long': 75},
            '5m': {'atr_multiplier': 1.0, 'rsi_period': 12, 'ema_short': 20, 'ema_long': 100},
            '15m': {'atr_multiplier': 1.1, 'rsi_period': 14, 'ema_short': 25, 'ema_long': 150},
            '1h': {'atr_multiplier': 1.3, 'rsi_period': 16, 'ema_short': 30, 'ema_long': 200},
            '4h': {'atr_multiplier': 1.5, 'rsi_period': 18, 'ema_short': 40, 'ema_long': 200},
            '1d': {'atr_multiplier': 2.0, 'rsi_period': 20, 'ema_short': 50, 'ema_long': 200}
        })
        
        # Limites para otimização
        self.period_min = config.get('period_min', 5)
        self.period_max = config.get('period_max', 50)
        
        # Estado atual
        self.current_timeframe = None
        self.current_params = None

    def set_timeframe(self, timeframe: str) -> None:
        """Define o timeframe atual e ajusta os parâmetros"""
        self.current_timeframe = timeframe
        self.current_params = self.timeframe_adjustments.get(timeframe, {
            'atr_multiplier': 1.0,
            'rsi_period': 14,
            'ema_short': 20,
            'ema_long': 200
        })

    def _calculate_true_range(self, high: pd.Series, low: pd.Series, close: pd.Series) -> pd.Series:
        """Calcula o True Range de forma eficiente"""
        tr1 = high - low
        tr2 = (high - close.shift(1)).abs()
        tr3 = (low - close.shift(1)).abs()
        return pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

    def _optimize_atr_period(self, high: pd.Series, low: pd.Series, close: pd.Series) -> int:
        """Otimiza o período do ATR para a volatilidade atual"""
        def objective(period):
            period = int(round(period))
            tr = self._calculate_true_range(high, low, close)
            atr = tr.rolling(window=period).mean()
            return atr.dropna().var()
            
        result = minimize_scalar(
            objective,
            bounds=(self.period_min, self.period_max),
            method='bounded'
        )
        return int(round(result.x))

    def _calculate_adaptive_atr(self, df: pd.DataFrame) -> pd.DataFrame:
        """Calcula múltiplos ATRs adaptados ao timeframe atual"""
        timeframe_periods = {
            '30s': (3, 14, 50),
            '1m': (5, 14, 60),
            '5m': (7, 21, 80),
            '15m': (10, 21, 100),
            '1h': (14, 21, 100),
            '4h': (14, 50, 150),
            '1d': (14, 50, 200)
        }
        
        if self.current_timeframe not in timeframe_periods:
            raise ValueError(f"Timeframe '{self.current_timeframe}' não suportado")

        p_short, p_medium, p_long = timeframe_periods[self.current_timeframe]
        
        df['ATR_short'] = self._calculate_atr(df, p_short)
        df['ATR_medium'] = self._calculate_atr(df, p_medium)
        df['ATR_long'] = self._calculate_atr(df, p_long)
        
        return df

    def _select_best_atr(self, df: pd.DataFrame, lookback: int = 14) -> pd.Series:
        """Seleciona dinamicamente o melhor ATR baseado nas condições de mercado"""
        df = df.copy()
        
        # Indicadores auxiliares para seleção
        df['range'] = df['high'] - df['low']
        df['avg_range'] = df['range'].rolling(lookback).mean()
        df['upper_wick'] = df['high'] - df[['close', 'open']].max(axis=1)
        df['lower_wick'] = df[['close', 'open']].min(axis=1) - df['low']
        df['wick_ratio'] = (df['upper_wick'] + df['lower_wick']) / df['range']
        df['body_ratio'] = (df['close'] - df['open']).abs() / df['range']
        df['doji'] = df['body_ratio'] < 0.1
        df['doji_ratio'] = df['doji'].rolling(lookback).mean()
        df['volatility_std'] = df['close'].rolling(lookback).std()

        # Seleção dinâmica
        selected_atr = []
        for i in range(len(df)):
            # Condições de mercado
            high_volatility = df['volatility_std'].iloc[i] > (df['avg_range'].iloc[i] * 1.2)
            low_noise = (df['wick_ratio'].iloc[i] < 0.3) and (df['doji_ratio'].iloc[i] < 0.2)
            strong_trend = (df['ADX'].iloc[i] > 25) if 'ADX' in df else False
            high_volume = df['volume'].iloc[i] > df['volume'].rolling(lookback).mean().iloc[i] * 1.5

            # Regras profissionais
            if strong_trend and high_volatility and high_volume:
                selected_atr.append(df['ATR_short'].iloc[i])  # Tendência forte
            elif not strong_trend and (df['doji_ratio'].iloc[i] > 0.3 or df['wick_ratio'].iloc[i] > 0.4):
                selected_atr.append(df['ATR_long'].iloc[i])   # Mercado lateral/ruidoso
            else:
                selected_atr.append(df['ATR_medium'].iloc[i])  # Padrão

        return pd.Series(selected_atr, index=df.index)

    def _calculate_atr(self, df: pd.DataFrame, period: int) -> pd.Series:
        """Calcula o Average True Range para um período específico"""
        high_low = df['high'] - df['low']
        high_close = (df['high'] - df['close'].shift()).abs()
        low_close = (df['low'] - df['close'].shift()).abs()
        true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
        return true_range.rolling(window=period).mean()

    def _calculate_adaptive_bands(self, close: pd.Series, atr: float) -> tuple:
        """Calcula bandas dinâmicas baseadas no ATR"""
        if not self.current_params:
            raise ValueError("Timeframe não definido. Chame set_timeframe() primeiro.")
            
        multiplier = self.current_params['atr_multiplier']
        upper_band = close.iloc[-1] + (atr * multiplier)
        lower_band = close.iloc[-1] - (atr * multiplier)
        return upper_band, lower_band

    def _get_trend_direction(self, close: pd.Series, ema_short: pd.Series, ema_long: pd.Series) -> str:
        """Determina a direção da tendência com múltiplas confirmações"""
        price = close.iloc[-1]
        ema_s = ema_short.iloc[-1]
        ema_l = ema_long.iloc[-1]
        
        if price > ema_s > ema_l:
            return 'up'
        elif price < ema_s < ema_l:
            return 'down'
        return 'neutral'

    def _calculate_volume_profile(self, volume: pd.Series, lookback: int = 20) -> dict:
        """Analisa o perfil de volume para confirmação"""
        recent_vol = volume.iloc[-lookback:]
        avg_vol = recent_vol.mean()
        current_vol = volume.iloc[-1]
        
        return {
            'avg_volume': avg_vol,
            'current_volume': current_vol,
            'volume_ratio': current_vol / avg_vol if avg_vol > 0 else 1,
            'is_volume_spike': current_vol > (avg_vol * self.volume_threshold)
        }

    def generate_signal(self, df: pd.DataFrame, account_balance: Optional[float] = None) -> Optional[dict]:
        """
        Gera sinais de trading com múltiplas confirmações
        Args:
            df: DataFrame com colunas ['open', 'high', 'low', 'close', 'volume']
            account_balance: Saldo da conta para cálculo de position sizing
        Returns:
            Dicionário com sinal e metadados ou None se nenhum sinal
        """
        try:
            if df is None or len(df) < self.period_max * 2:
                return None
                
            if not self.current_timeframe:
                raise ValueError("Timeframe não definido. Chame set_timeframe() primeiro.")

            # 1. Calcula múltiplos ATRs e seleciona o melhor
            df = self._calculate_adaptive_atr(df)
            df['ATR_selected'] = self._select_best_atr(df)
            atr = df['ATR_selected'].iloc[-1]
            
            # 2. Indicadores adaptativos por timeframe (agora com ema_long dinâmico)
            rsi_period = self.current_params['rsi_period']
            ema_short_period = self.current_params['ema_short']
            ema_long_period = self.current_params['ema_long']
            
            rsi = talib.RSI(df['close'], timeperiod=rsi_period)
            ema_short = df['close'].ewm(span=ema_short_period, adjust=False).mean()
            ema_long = df['close'].ewm(span=ema_long_period, adjust=False).mean()
            
            # 3. Análise de tendência e momentum
            trend = self._get_trend_direction(df['close'], ema_short, ema_long)
            rsi_value = rsi.iloc[-1]
            momentum = 'bullish' if rsi_value > 50 else 'bearish'
            
            # 4. Bandas dinâmicas e análise de preço
            upper_band, lower_band = self._calculate_adaptive_bands(df['close'], atr)
            last_close = df['close'].iloc[-1]
            prev_close = df['close'].iloc[-2] if len(df['close']) > 1 else last_close
            
            # 5. Análise de volume
            volume_profile = self._calculate_volume_profile(df['volume'])
            
            # 6. Geração de sinais com múltiplas confirmações
            signal = None
            confidence = 0
            event = ""
            
            # Regra 1: Breakout com tendência e momentum
            if (last_close > upper_band and prev_close <= upper_band and 
                trend == 'up' and momentum == 'bullish'):
                signal = 'up'
                event = 'breakout_with_trend'
                confidence = 80
                
            elif (last_close < lower_band and prev_close >= lower_band and 
                  trend == 'down' and momentum == 'bearish'):
                signal = 'down'
                event = 'breakout_with_trend'
                confidence = 80
                
            # Regra 2: Pullback em tendência com volume
            elif (trend == 'up' and last_close > ema_short.iloc[-1] and 
                  rsi_value > 40 and rsi_value < 70 and
                  volume_profile['is_volume_spike']):
                signal = 'up'
                event = 'pullback_with_volume'
                confidence = 75
                
            elif (trend == 'down' and last_close < ema_short.iloc[-1] and 
                  rsi_value < 60 and rsi_value > 30 and
                  volume_profile['is_volume_spike']):
                signal = 'down'
                event = 'pullback_with_volume'
                confidence = 75
                
            # Se nenhum sinal válido, retorna None
            if not signal or confidence < self.min_confidence:
                return None
                
            # 7. Cálculo de stop e position sizing
            if signal == 'up':
                stop_loss = min(df['low'].iloc[-1], df['low'].iloc[-2] if len(df['low']) > 1 else df['low'].iloc[-1]) - (atr * 0.5)
                take_profit = last_close + (2 * atr)
            else:
                stop_loss = max(df['high'].iloc[-1], df['high'].iloc[-2] if len(df['high']) > 1 else df['high'].iloc[-1]) + (atr * 0.5)
                take_profit = last_close - (2 * atr)
            
            position_size = None
            if account_balance and stop_loss:
                risk_amount = account_balance * self.position_risk_pct
                stop_distance = abs(last_close - stop_loss)
                position_size = round(risk_amount / stop_distance, 2) if stop_distance > 0 else 0
                
            # 8. Montagem do resultado
            result = {
                'signal': signal,
                'event': event,
                'confidence': confidence,
                'price': last_close,
                'stop_loss': stop_loss,
                'take_profit': take_profit,
                'position_size': position_size,
                'atr': round(atr, 5),
                'atr_period': 'dynamic',
                'rsi': round(rsi_value, 2),
                'trend': trend,
                'momentum': momentum,
                'volume_ratio': round(volume_profile['volume_ratio'], 2),
                'timeframe': self.current_timeframe,
                'timestamp': df.index[-1],
                'atr_type': self._get_atr_type(df),  # Retorna 'short', 'medium' ou 'long'
                'ema_short_period': self.current_params['ema_short'],
                'ema_long_period': self.current_params['ema_long']
            }
            
            return result
            
        except Exception as e:
            print(f"ATRStrategyPro error: {str(e)}")
            return None

    def _get_atr_type(self, df: pd.DataFrame) -> str:
        """Identifica qual ATR está sendo usado (short/medium/long)"""
        current_atr = df['ATR_selected'].iloc[-1]
        if current_atr == df['ATR_short'].iloc[-1]:
            return 'short'
        elif current_atr == df['ATR_medium'].iloc[-1]:
            return 'medium'
        else:
            return 'long'
