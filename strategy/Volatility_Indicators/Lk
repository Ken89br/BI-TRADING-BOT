import pandas as pd
import numpy as np
import talib
from typing import Dict, List, Optional, Union

class BollingerBandsPro:
    """
    Estratégia Bollinger Bands Pro com:
    - Timeframes de 30s a 4h
    - Parâmetros adaptativos para cada timeframe
    - Detecção de squeeze com confirmação (Bollinger vs Keltner)
    - Filtros de tendência (EMA), momentum (RSI) e volume
    - Gerenciamento de risco baseado em ATR
    - Padrões de candlestick como confirmação adicional
    """
    
    def __init__(self, config: Optional[Dict] = None):
        """
        Inicializa a estratégia com configurações padrão ou personalizadas.
        Args:
            config: Dicionário com parâmetros customizados (opcional).
                   Exemplo: {'timeframe_adjustments': {'1m': {'period': 14, ...}}}
        """
        self.config = config or {}
        
        # Configurações padrão para cada timeframe (podem ser sobrescritas pelo config)
        self.timeframe_adjustments = {
            '30s': {
                'period': 8,    # Período das Bollinger Bands
                'std_dev': 1.4, # Número de desvios padrão
                'ema_trend': 30, # EMA para tendência (curta)
                'ema_long': 60,  # EMA longa (filtro adicional)
                'rsi_period': 8, # Período do RSI
                'atr_multiplier': 0.7 # Multiplicador para stops
            },
            '1m': {
                'period': 10,
                'std_dev': 1.5,
                'ema_trend': 50,
                'ema_long': 100,
                'rsi_period': 10,
                'atr_multiplier': 0.8
            },
            '2m': {
                'period': 12,
                'std_dev': 1.6,
                'ema_trend': 75,
                'ema_long': 120,
                'rsi_period': 10,
                'atr_multiplier': 0.9
            },
            '5m': {
                'period': 14,
                'std_dev': 1.8,
                'ema_trend': 100,
                'ema_long': 150,
                'rsi_period': 12,
                'atr_multiplier': 1.0
            },
            '15m': {
                'period': 20,
                'std_dev': 2.0,
                'ema_trend': 150,
                'ema_long': 200,
                'rsi_period': 14,
                'atr_multiplier': 1.2
            },
            '1h': {
                'period': 30,
                'std_dev': 2.2,
                'ema_trend': 200,
                'ema_long': 200,
                'rsi_period': 16,
                'atr_multiplier': 1.5
            },
            '2h': {
                'period': 35,
                'std_dev': 2.3,
                'ema_trend': 200,
                'ema_long': 200,
                'rsi_period': 18,
                'atr_multiplier': 1.7
            },
            '4h': {
                'period': 40,
                'std_dev': 2.5,
                'ema_trend': 200,
                'ema_long': 200,
                'rsi_period': 20,
                'atr_multiplier': 2.0
            }
        }
        
        # Atualiza com configurações personalizadas se fornecidas
        if 'timeframe_adjustments' in self.config:
            for tf in self.config['timeframe_adjustments']:
                if tf in self.timeframe_adjustments:
                    self.timeframe_adjustments[tf].update(self.config['timeframe_adjustments'][tf])

    def calculate_bands(self, close: pd.Series, timeframe: str) -> Dict[str, pd.Series]:
        """
        Calcula as Bollinger Bands com parâmetros adaptados ao timeframe.
        Retorna: upper_band, middle_band, lower_band, bandwidth
        """
        params = self.timeframe_adjustments[timeframe]
        middle_band = close.rolling(window=params['period']).mean()
        std = close.rolling(window=params['period']).std()
        upper_band = middle_band + (std * params['std_dev'])
        lower_band = middle_band - (std * params['std_dev'])
        bandwidth = (upper_band - lower_band) / middle_band * 100  # % de largura
        
        return {
            'upper': upper_band,
            'middle': middle_band,
            'lower': lower_band,
            'bandwidth': bandwidth
        }

    def calculate_keltner(self, high: pd.Series, low: pd.Series, close: pd.Series, period: int = 20) -> Dict[str, pd.Series]:
        """
        Calcula os Keltner Channels para detecção de squeeze.
        Retorna: upper_keltner, lower_keltner
        """
        atr = talib.ATR(high, low, close, timeperiod=period)
        middle = close.ewm(span=period).mean()
        upper_keltner = middle + (atr * 1.5)
        lower_keltner = middle - (atr * 1.5)
        
        return {
            'upper': upper_keltner,
            'lower': lower_keltner
        }

    def detect_squeeze(self, bb_upper: float, bb_lower: float, kelt_upper: float, kelt_lower: float) -> bool:
        """
        Detecta condições de squeeze REAL (Bollinger dentro de Keltner).
        """
        return (bb_upper < kelt_upper) and (bb_lower > kelt_lower)

    def detect_candlestick_patterns(self, open: pd.Series, high: pd.Series, low: pd.Series, close: pd.Series) -> List[str]:
        """
        Identifica padrões de candlestick relevantes (simplificado).
        """
        patterns = []
        
        # Hammer (baixa) e Inverted Hammer (alta)
        if (close[-1] > open[-1] and 
            (high[-1] - close[-1]) / (high[-1] - low[-1]) < 0.3 and 
            (close[-1] - low[-1]) / (high[-1] - low[-1]) > 0.6):
            patterns.append('hammer')
            
        # Engulfing bullish/bearish
        if (close[-1] > open[-1] and close[-2] < open[-2] and 
            close[-1] > open[-2] and open[-1] < close[-2]):
            patterns.append('bullish_engulfing')
            
        # Adicione outros padrões conforme necessário...
        
        return patterns

    def generate_signal(self, df: pd.DataFrame, timeframe: str) -> Optional[Dict]:
        """
        Gera sinais de trading com múltiplas confirmações.
        Args:
            df: DataFrame com colunas ['open', 'high', 'low', 'close', 'volume']
            timeframe: Timeframe para ajuste de parâmetros (ex: '5m')
        Returns:
            Dicionário com sinal e metadados ou None se nenhum sinal válido
        """
        try:
            if timeframe not in self.timeframe_adjustments:
                raise ValueError(f"Timeframe {timeframe} não suportado")
                
            params = self.timeframe_adjustments[timeframe]
            
            # 1. Calcula indicadores
            bands = self.calculate_bands(df['close'], timeframe)
            keltner = self.calculate_keltner(df['high'], df['low'], df['close'])
            rsi = talib.RSI(df['close'], timeperiod=params['rsi_period'])
            ema_trend = df['close'].ewm(span=params['ema_trend']).mean()
            ema_long = df['close'].ewm(span=params['ema_long']).mean()
            adx = talib.ADX(df['high'], df['low'], df['close'], timeperiod=14)
            atr = talib.ATR(df['high'], df['low'], df['close'], timeperiod=14).iloc[-1]
            
            # 2. Condições atuais
            current_price = df['close'].iloc[-1]
            prev_price = df['close'].iloc[-2] if len(df) > 1 else current_price
            volume_avg = df['volume'].rolling(20).mean().iloc[-1]
            
            current = {
                'price': current_price,
                'trend': 'up' if (current_price > ema_trend.iloc[-1] and ema_trend.iloc[-1] > ema_long.iloc[-1]) else 'down',
                'squeeze': self.detect_squeeze(
                    bands['upper'].iloc[-1], 
                    bands['lower'].iloc[-1],
                    keltner['upper'].iloc[-1],
                    keltner['lower'].iloc[-1]
                ),
                'rsi': rsi.iloc[-1],
                'adx': adx.iloc[-1],
                'volume_spike': df['volume'].iloc[-1] > volume_avg * 1.5,
                'bandwidth_expanding': bands['bandwidth'].iloc[-1] > bands['bandwidth'].rolling(10).mean().iloc[-1]
            }
            
            # 3. Padrões de candlestick
            patterns = self.detect_candlestick_patterns(df['open'], df['high'], df['low'], df['close'])
            has_bullish_pattern = any(p in ['hammer', 'bullish_engulfing'] for p in patterns)
            has_bearish_pattern = any(p in ['shooting_star', 'bearish_engulfing'] for p in patterns)
            
            # 4. Regras de entrada
            signal = None
            reason = []
            
            # Breakout com tendência e confirmação
            if (current['trend'] == 'up' and 
                current_price > bands['upper'].iloc[-1] and 
                prev_price <= bands['upper'].iloc[-2] and 
                current['adx'] > 25 and 
                current['volume_spike'] and 
                has_bullish_pattern):
                signal = 'up'
                reason.append('breakout_up_trend')
                
            elif (current['trend'] == 'down' and 
                  current_price < bands['lower'].iloc[-1] and 
                  prev_price >= bands['lower'].iloc[-2] and 
                  current['adx'] > 25 and 
                  current['volume_spike'] and 
                  has_bearish_pattern):
                signal = 'down'
                reason.append('breakout_down_trend')
                
            # Squeeze breakout
            elif current['squeeze']:
                if (current_price > bands['upper'].iloc[-1] and 
                    current['bandwidth_expanding'] and 
                    current['volume_spike']):
                    signal = 'up'
                    reason.append('squeeze_breakout_up')
                elif (current_price < bands['lower'].iloc[-1] and 
                      current['bandwidth_expanding'] and 
                      current['volume_spike']):
                    signal = 'down'
                    reason.append('squeeze_breakout_down')
            
            # 5. Se nenhum sinal válido, retorna None
            if not signal:
                return None
                
            # 6. Gerenciamento de risco
            if signal == 'up':
                stop_loss = min(
                    bands['lower'].iloc[-1],
                    df['low'].iloc[-1],
                    df['low'].rolling(5).min().iloc[-1]
                ) - (atr * 0.5)
                take_profit = current_price + (atr * 2)
            else:
                stop_loss = max(
                    bands['upper'].iloc[-1],
                    df['high'].iloc[-1],
                    df['high'].rolling(5).max().iloc[-1]
                ) + (atr * 0.5)
                take_profit = current_price - (atr * 2)
            
            # 7. Monta o resultado
            return {
                'signal': signal,
                'reason': reason,
                'price': current_price,
                'stop_loss': stop_loss,
                'take_profit': take_profit,
                'indicators': {
                    'rsi': round(current['rsi'], 2),
                    'adx': round(current['adx'], 2),
                    'ema_trend': round(ema_trend.iloc[-1], 5),
                    'ema_long': round(ema_long.iloc[-1], 5),
                    'atr': round(atr, 5),
                    'bandwidth': round(bands['bandwidth'].iloc[-1], 2)
                },
                'volume': df['volume'].iloc[-1],
                'volume_avg': round(volume_avg, 2),
                'patterns': patterns,
                'timeframe': timeframe
            }
            
        except Exception as e:
            print(f"Erro ao gerar sinal: {str(e)}")
            return None
